# Longest Nice Subarray (LeetCode 2401)

## Problem Statement
You are given an array `nums` consisting of positive integers.

A subarray of `nums` is called **nice** if the bitwise **AND** of every pair of elements in different positions in the subarray is **0**.

Return the length of the **longest nice subarray**.

A subarray is a contiguous part of an array. Note that subarrays of length `1` are always considered nice.

### Example 1:
```plaintext
Input: nums = [1,3,8,48,10]
Output: 3
Explanation: The longest nice subarray is [3,8,48]. This subarray satisfies:
- 3 & 8 = 0
- 3 & 48 = 0
- 8 & 48 = 0
```

### Example 2:
```plaintext
Input: nums = [3,1,5,11,13]
Output: 1
Explanation: The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.
```

### Constraints:
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`

---

## Optimized Approach: Sliding Window
### Key Idea:
- Use a **sliding window** approach with two pointers (`left` and `right`).
- Maintain a **bitmask** to track the bitwise OR of all elements in the current window.
- Expand the `right` boundary and check if adding `nums[right]` keeps the subarray "nice".
- If not, move the `left` pointer to shrink the window until it is valid again.
- Keep track of the **maximum window size**.

### Code Implementation (Java)
```java
class Solution {
    public int longestNiceSubarray(int[] nums) {
        int left = 0, bitMask = 0, maxLen = 0;

        for (int right = 0; right < nums.length; right++) {
            while ((bitMask & nums[right]) != 0) {
                bitMask ^= nums[left];  // Remove left element from bitMask
                left++;                 // Move left pointer forward
            }
            bitMask |= nums[right];  // Add new element to bitMask
            maxLen = Math.max(maxLen, right - left + 1);
        }
        return maxLen;
    }
}
```

### Time Complexity:
- **O(n)** → Each element is processed at most twice (once when added, once when removed).

### Space Complexity:
- **O(1)** → Uses only integer variables (bitMask, left, maxLen).

---

## Explanation with Example:
### Input:
```plaintext
nums = [1,3,8,48,10]
```
### Step-by-Step Execution:
| Step | Left | Right | Window | Bitmask | Max Length |
|------|------|-------|--------|---------|------------|
| 1    | 0    | 0     | [1]    | 1       | 1          |
| 2    | 0    | 1     | [1,3]  | 3       | 2          |
| 3    | 0    | 2     | [1,3,8]| 11      | 3          |
| 4    | 1    | 3     | [3,8,48] | 59    | 3          |
| 5    | 2    | 4     | [8,48,10] | 58   | 3          |

The longest nice subarray has a **length of 3**.

---

## Alternative Approaches
### 1. Brute Force (O(n²))
- Try all possible subarrays and check if they are "nice".
- Inefficient for large inputs.

### 2. Binary Search + Checking (O(n log n))
- Use binary search on the length and check if a subarray of that length is "nice".
- Still slower than the sliding window approach.

---

## Summary
✅ **Optimized solution uses a sliding window** for an **O(n) runtime**.
✅ **Space complexity is O(1)**, using only a few integer variables.
✅ **More efficient than brute force (O(n²)) or binary search (O(n log n))**.

---

### 🚀 If you found this helpful, give it a ⭐ on GitHub!

